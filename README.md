Код:

import pandas as pd

# ШАГ 1: Загрузка и первичный осмотр данных
print("=" * 50)
print("ШАГ 1: Загрузка и первичный осмотр данных")
print("=" * 50)

# 1. Загрузите данные
try:
    df = pd.read_csv('ncr_ride_bookings.csv')
    print("Файл 'ncr_ride_bookings.csv' загружен успешно!")
except FileNotFoundError:
    try:
        df = pd.read_csv('датаcer_uber_pides_bookings.csv')
        print("Файл 'датаcer_uber_pides_bookings.csv' загружен успешно!")
    except FileNotFoundError:
        print("ОШИБКА: Файл не найден!")
        exit()

# 2. Выведите первые 5 строк
print("\n1. Первые 5 строк данных:")
print(df.head())
print("\n" + "-"*30)

# 3. Выведите общую информацию
print("2. Общая информация о данных:")
df.info()
print("\n" + "-"*30)

# 4. Выведите статистическое описание
print("3. Статистическое описание числовых столбцов:")
print(df.describe())
print("\n" + "-"*30)

# 5. Определите количество строк и столбцов
print("4. Количество строк и столбцов:")
print(f"Строк: {df.shape[0]}, Столбцов: {df.shape[1]}")
print("\n" + "-"*30)

# Покажем все столбцы для понимания структуры данных
print("ВСЕ СТОЛБЦЫ В ДАННЫХ:")
for i, col in enumerate(df.columns, 1):
    print(f"{i}. {col}")

print("\n" + "-"*30)

# ШАГ 3: Выборка и фильтрация данных
print("=" * 50)
print("ШАГ 3: Выборка и фильтрация данных")
print("=" * 50)

# Посмотрим на данные чтобы понять какие столбцы использовать
print("Для выполнения заданий нам нужно определить правильные названия столбцов.")
print("Посмотрите на список выше и введите нужные названия:")

# Автоматически попробуем найти похожие столбцы
all_columns = df.columns.tolist()

# Попробуем найти столбцы по ключевым словам
booking_id_cols = [col for col in all_columns if 'booking' in col.lower() and 'id' in col.lower()]
datetime_cols = [col for col in all_columns if any(x in col.lower() for x in ['date', 'time', 'datetime'])]
status_cols = [col for col in all_columns if 'status' in col.lower()]
vehicle_cols = [col for col in all_columns if 'vehicle' in col.lower() or 'auto' in col.lower()]
payment_cols = [col for col in all_columns if 'payment' in col.lower()]
value_cols = [col for col in all_columns if 'value' in col.lower() or 'price' in col.lower() or 'cost' in col.lower()]

print(f"Возможные столбцы для Booking ID: {booking_id_cols}")
print(f"Возможные столбцы для даты/времени: {datetime_cols}")
print(f"Возможные столбцы для статуса: {status_cols}")
print(f"Возможные столбцы для типа транспорта: {vehicle_cols}")
print(f"Возможные столбцы для оплаты: {payment_cols}")
print(f"Возможные столбцы для стоимости: {value_cols}")

# Используем первые найденные столбцы или просим пользователя ввести
booking_id_col = booking_id_cols[0] if booking_id_cols else 'Booking ID'
datetime_col = datetime_cols[0] if datetime_cols else 'booking_datetime'
status_col = status_cols[0] if status_cols else 'Booking Status'
vehicle_col = vehicle_cols[0] if vehicle_cols else 'Vehicle Type'
payment_col = payment_cols[0] if payment_cols else 'Payment Method'
value_col = value_cols[0] if value_cols else 'Booking Value'

print(f"\nИспользуем столбцы:")
print(f"Booking ID: {booking_id_col}")
print(f"Дата/время: {datetime_col}")
print(f"Статус: {status_col}")
print(f"Тип транспорта: {vehicle_col}")
print(f"Оплата: {payment_col}")
print(f"Стоимость: {value_col}")

print("\n" + "-"*30)

# 1. Выберите только нужные столбцы
print("1. Выбранные столбцы (первые 5 строк):")
try:
    selected_columns = df[[booking_id_col, datetime_col, status_col, vehicle_col, payment_col]]
    print(selected_columns.head())
except KeyError as e:
    print(f"Ошибка: столбец {e} не найден. Проверьте названия столбцов.")

print("\n" + "-"*30)

# 2. Фильтрация по статусу
print("2. Бронирования со статусом 'Cancelled by Driver':")
try:
    cancelled_by_driver = df[df[status_col] == 'Cancelled by Driver']
    print(cancelled_by_driver)
    print(f"Найдено: {len(cancelled_by_driver)} записей")
except KeyError:
    print("Столбец статуса не найден")

print("\n" + "-"*30)

# 3. Фильтрация по Auto и стоимости > 500
print("3. Бронирования Auto с Booking Value > 500:")
try:
    auto_high_value = df[(df[vehicle_col] == 'Auto') & (df[value_col] > 500)]
    print(auto_high_value)
    print(f"Найдено: {len(auto_high_value)} записей")
except KeyError:
    print("Не удалось выполнить фильтрацию. Проверьте названия столбцов.")

print("\n" + "-"*30)

# 4. Фильтрация по датам марта 2024
print("4. Бронирования за март 2024 года:")
try:
    # Преобразуем дату в правильный формат
    df[datetime_col] = pd.to_datetime(df[datetime_col])
    march_2024 = df[(df[datetime_col] >= '2024-03-01') & (df[datetime_col] <= '2024-03-31')]
    print(march_2024)
    print(f"Найдено: {len(march_2024)} записей")
except KeyError:
    print("Столбец с датой не найден")
except Exception as e:
    print(f"Ошибка при работе с датами: {e}")

print("=" * 50)
print("АНАЛИЗ ЗАВЕРШЕН!")
print("=" * 50)

Объяснение:

1. Импорт библиотеки
python
import pandas as pd
Что делает: Подключает библиотеку Pandas для работы с табличными данными. pd - это короткое имя для удобства.

2. Загрузка данных

python
try:
    df = pd.read_csv('ncr_ride_bookings.csv')
except FileNotFoundError:
    try:
        df = pd.read_csv('датаcer_uber_pides_bookings.csv')
    except FileNotFoundError:
        print("ОШИБКА: Файл не найден!")
        exit()
Как работает: Пытается загрузить файл. Если первого файла нет - пробует второй. Если оба не найдены - останавливает программу.

4. Первичный анализ данных
python
print(df.head())      # Показывает первые 5 строк
df.info()            # Информация о данных (типы, количество)
print(df.describe()) # Статистика по числам
print(df.shape)      # Размер таблицы (строки, столбцы)
Зачем нужно: Чтобы понять что за данные, сколько их, какие типы информации.

5. Поиск нужных столбцов
python
booking_id_cols = [col for col in all_columns if 'booking' in col.lower() and 'id' in col.lower()]
Как работает: Ищет столбцы где в названии есть и 'booking' и 'id'. Например: "Booking_ID", "bookingId" и т.д.

6. Выборка столбцов
python
selected_columns = df[['Booking ID', 'booking_datetime', 'Booking Status', 'Vehicle Type', 'Payment Method']]
Что делает: Берет только указанные столбцы из всей таблицы.

7. Фильтрация данных
python
# Фильтр по статусу
cancelled_by_driver = df[df['Booking Status'] == 'Cancelled by Driver']

# Фильтр по двум условиям
auto_high_value = df[(df['Vehicle Type'] == 'Auto') & (df['Booking Value'] > 500)]
Как работает:

df[условие] - выбирает строки где условие True

& - логическое "И" (оба условия должны быть true)

== - проверка на равенство

7. Фильтрация по датам
python
df['booking_datetime'] = pd.to_datetime(df['booking_datetime'])  # Преобразует текст в дату
march_2024 = df[(df['booking_datetime'] >= '2024-03-01') & (df['booking_datetime'] <= '2024-03-31')]
Зачем: Чтобы можно было сравнивать даты как числа (больше/меньше).

Основные концепции:
DataFrame (df) - это таблица Excel в коде
Столбцы - как колонки в Excel
Строки - как строки в Excel
Фильтрация - выбор только нужных строк
Выборка - выбор только нужных столбцов

# Лабороторная  №2

Краткое описание кода:
ШАГ 1: Загрузка и первичный осмотр данных

Загружает CSV файл с бронированиями поездок

Показывает первые 5 строк для понимания структуры данных

Выводит общую информацию о данных (типы столбцов, пропуски)

Отображает статистику по числовым столбцам

Списывает все названия столбцов

ШАГ 2: Статистический обзор данных

Анализирует пропущенные значения по каждому столбцу

Показывает типы данных и количество уникальных значений

Автоматически находит столбцы со статусами и типами транспорта

Анализирует категориальные переменные (статусы, типы транспорта)

Выводит статистику по числовым столбцам

ШАГ 3: Выборка и фильтрация данных

Автоматически идентифицирует ключевые столбцы (ID, дата, статус, транспорт, оплата, стоимость)

Выполняет фильтрации:

Показывает выбранные столбцы

Находит бронирования, отмененные водителем

Ищет поездки на Auto с высокой стоимостью

Фильтрует бронирования за март 2024 года

Ключевые особенности:

Автоматическое определение столбцов по ключевым словам

Обработка ошибок при отсутствии столбцов

Гибкая фильтрация данных по различным условиям

Подробная статистическая информация о данных

# Лабороторная  №3

Краткое описание кода:
Цель проекта: Создание модели машинного обучения для прогнозирования отмен поездок в сервисе бронирования.

Основные этапы:
ШАГ 1-2: Анализ данных

Загрузка и исследование датасета с бронированиями

Анализ пропущенных значений, типов данных и статистики

Автоматическое определение ключевых столбцов (статус, транспорт, стоимость и т.д.)

ШАГ 3: Фильтрация данных

Поиск и фильтрация данных по различным условиям:

Отмененные водителем поездки

Поездки на Auto с высокой стоимостью

Бронирования за конкретный период

ШАГ 4: Подготовка для ML

Создание бинарной целевой переменной "is_cancelled" (отменена/не отменена)

Извлечение признаков: числовые, категориальные, временные (час, день недели)

Заполнение пропусков и кодирование категориальных переменных

ШАГ 5: Обучение модели

Использование Random Forest Classifier

Разделение данных на обучающую/тестовую выборки

Обучение модели с балансировкой классов

ШАГ 6: Оценка и прогнозы

Анализ точности модели и матрицы ошибок

Определение важности признаков

Примеры прогнозов для новых данных

Бизнес-инсайты: анализ факторов, влияющих на отмены

Ключевые результаты:
Модель предсказывает вероятность отмены поездки

Бизнес-применение: снижение количества отмен через выявление проблемных часов, типов транспорта и методов оплаты

Метрики: оценка точности, важности признаков, практические рекомендации

Проект демонстрирует полный цикл Data Science: от анализа данных до внедрения ML-модели с бизнес-рекомендациями.

# Машинное обучение

ШАГ 1: ПЕРВИЧНЫЙ АНАЛИЗ ДАННЫХ
1.1 Загрузка и валидация данных
python
# Проверка наличия файла и загрузка
df = pd.read_csv('ncr_ride_bookings.csv')
Цель: Убедиться в доступности данных и загрузить их

Выходные данные: DataFrame с исходными данными

Контроль качества: Обработка ошибки если файл не найден

1.2 Эксплораторный анализ данных
Методы:

df.head() - просмотр первых 5 строк для понимания структуры

df.info() - информация о типах данных и пропусках

df.describe() - статистика числовых столбцов

df.shape - размерность данных

Назначение: Понимание структуры данных, выявление очевидных проблем

1.3 Автоматическое определение целевой переменной
python
value_columns = [col for col in df.columns if any(x in col.lower() for x in
                 ['value', 'price', 'cost', 'amount', 'fare', 'charge'])]
Алгоритм:

Поиск столбцов по ключевым словам, связанным со стоимостью

Если не найдено - берется первый числовой столбец

Детальный анализ статистик целевой переменной

1.4 Визуализация распределения целевой переменной
6 типов графиков:

Гистограмма - общее распределение стоимости

Усеченная гистограмма (до 99% перцентиля) - без экстремальных выбросов

Boxplot - визуализация выбросов

Анализ выбросов - столбчатая диаграмма распределения

Q-Q plot - проверка нормальности распределения

Кумулятивное распределение - интегральная функция распределения

1.5 Обработка выбросов методом Winsorization
python
upper_95 = df[value_col].quantile(0.95)
df_processed[value_col] = np.where(df_processed[value_col] > upper_95, upper_95, df_processed[value_col])
Стратегия: Все значения выше 95% перцентиля заменяются на значение 95% перцентиля
Преимущество: Сохранение информации о выбросах без искажения модели

ШАГ 2: АНАЛИЗ СТРУКТУРЫ ДАННЫХ И СОЗДАНИЕ ПРИЗНАКОВ
2.1 Автоматическая классификация столбцов
python
column_categories = {
    'vehicle_col': ['vehicle', 'auto', 'car', 'cab'],
    'datetime_col': ['date', 'time', 'datetime', 'timestamp'],
    # ... и другие категории
}
Категории столбцов:

Транспортные средства

Дата/время

Оплата

Расстояние

Длительность

Места посадки/высадки

Пользователи

Водители

2.2 Анализ пропущенных значений
Количественный анализ пропусков по столбцам

Процентное соотношение пропусков

Выявление проблемных столбцов

2.3 Классификация признаков
Категориальные: строковые данные (тип транспорта, метод оплаты)

Числовые: количественные данные (стоимость, расстояние)

2.4 Анализ категориальных признаков
Подсчет уникальных значений

Анализ распределения (топ-10 значений)

Визуализация через столбчатые диаграммы

ШАГ 3: СОЗДАНИЕ РАСШИРЕННЫХ ПРИЗНАКОВ
3.1 Временные признаки
Базовые:

hour - час суток (0-23)

day_of_week - день недели (0-6)

month - месяц (1-12)

day_of_month - день месяца (1-31)

week_of_year - неделя года (1-52)

Логические:

is_weekend - признак выходного дня

is_rush_hour - час пик (7-10, 16-19)

is_night - ночное время (23-5)

Циклические (для учета цикличности времени):

hour_sin, hour_cos - циклическое кодирование часа

day_sin, day_cos - циклическое кодирование дня недели

3.2 Статистические признаки
Признаки спроса:

hourly_demand - количество поездок по часам

daily_demand - количество поездок по дням недели

Статистики по стоимости:

hourly_mean_price - средняя стоимость по часам

hourly_std_price - стандартное отклонение по часам

hourly_median_price - медианная стоимость по часам

3.3 Частотное кодирование категориальных переменных
python
freq_encoding = df[cat_col].value_counts().to_dict()
df[f'{cat_col}_freq'] = df[cat_col].map(freq_encoding)
Принцип: Замена категорий на частоту их встречаемости в данных

3.4 Признаки взаимодействия
hour_demand_interaction - произведение часа и спроса

weekend_rush_interaction - взаимодействие выходных и часа пик

3.5 Поведенческие признаки
На основе пользователей:

user_mean_spend - средние траты пользователя

user_ride_count - количество поездок пользователя

user_std_spend - изменчивость трат пользователя

user_spend_variability - коэффициент вариации трат

3.6 Географические признаки
Обработка координат:

Округление координат для группировки

Кластеризация K-means для создания зон

location_cluster - идентификатор кластера местоположения

ШАГ 4: ПОДГОТОВКА ДАННЫХ ДЛЯ МОДЕЛИ
4.1 Создание финального набора данных
Выбор только релевантных признаков

Объединение всех созданных признаков

4.2 Обработка пропущенных значений
Стратегия:

Числовые признаки: заполнение медианой

Категориальные признаки: заполнение модой

4.3 Кодирование категориальных переменных
python
le = LabelEncoder()
final_data[col] = le.fit_transform(final_data[col].astype(str))
Метод: Label Encoding - преобразование строк в числовые коды

4.4 Очистка данных
Удаление строк с NaN значениями после преобразований

Проверка целостности данных

ШАГ 5: ОБУЧЕНИЕ МОДЕЛЕЙ МАШИННОГО ОБУЧЕНИЯ
5.1 Разделение данных
python
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y_bins
)
Стратегия: Стратифицированное разделение по квантилям стоимости

5.2 Масштабирование признаков
python
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
Метод: StandardScaler - приведение признаков к нулевому среднему и единичной дисперсии

5.3 Модели машинного обучения
Random Forest Regressor:

Ансамблевый метод на основе деревьев

Параметры: 100 деревьев, глубина 20, балансировка

Gradient Boosting Regressor:

Бустинговый алгоритм

Параметры: 100 estimators, глубина 6, learning rate 0.1

5.4 Метрики оценки качества
R² (Коэффициент детерминации): Доля объясненной дисперсии

MAE (Средняя абсолютная ошибка): Среднее абсолютное отклонение

RMSE (Среднеквадратичная ошибка): Квадратный корень из MSE

MAPE (Средняя абсолютная процентная ошибка): Ошибка в процентах

ШАГ 6: ОЦЕНКА КАЧЕСТВА МОДЕЛИ
6.1 Визуализация результатов
Три ключевых графика:

Предсказания vs Факт: scatter plot с линией идеального прогноза

Распределение ошибок: гистограмма ошибок предсказания

Важность признаков: топ-15 наиболее влиятельных признаков

6.2 Детальный анализ ошибок
Медианная абсолютная ошибка

75-й и 90-й процентили ошибок

Максимальная ошибка

Анализ распределения ошибок

ШАГ 7: БИЗНЕС-АНАЛИЗ И РЕКОМЕНДАЦИИ
7.1 Ключевые инсайты
Анализ по времени:

Самые дорогие часы для поездок

Распределение стоимости по дням недели

Анализ по типу транспорта:

Сравнение средней стоимости между типами транспортных средств

Популярность разных типов транспорта

7.2 Бизнес-рекомендации
Операционные улучшения:

Динамическое ценообразование

Оптимизация распределения транспорта

Специальные тарифы для разных временных окон

Управление доходами:

Продвижение премиальных услуг

Программы лояльности

Оптимизация ценообразования на основе спроса

Технические улучшения:

Прогнозирование спроса

Система рекомендаций

Дашборды для мониторинга

ТЕХНИЧЕСКИЕ ОСОБЕННОСТИ РЕАЛИЗАЦИИ
Обработка выбросов
Метод Winsorization вместо полного удаления

Сохранение информации о экстремальных значениях

Минимизация искажения распределения

Инженерия признаков
Комбинация domain knowledge и автоматического определения

Учет временных паттернов и цикличности

Создание признаков взаимодействия

Валидация модели
Стратифицированное разделение для сохранения распределения

Множественные метрики оценки

Визуальная проверка результатов

Масштабируемость
Автоматическое определение столбцов

Обработка различных форматов данных

Гибкая настройка параметров моделей

ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ
Для бизнеса:
Точное прогнозирование доходов

Оптимизация ценообразования

Улучшение пользовательского опыта

Снижение операционных затрат

Для пользователей:
Предсказуемая стоимость поездок

Оптимальный выбор времени для поездок

Прозрачное ценообразование

Эта модель представляет собой законченное решение для прогнозирования стоимости поездок, сочетающее передовые методы машинного обучения с практическими бизнес-потребностями.


